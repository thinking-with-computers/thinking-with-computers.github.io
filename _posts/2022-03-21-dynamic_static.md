---
title: Dynamic, static, and all that.
author: Scott
layout: post
tags: meta
---

One of the major things we are doing as part of the Thinking with Computers project is writing our own programming language. The rationale behind this--beyond the masochistic pleasure behind hacking on languages as artists and humanists--stems from Seymour Papert's notion of "procedural epistemology." Knowledge is always a kind of knowing-how, not a knowing-that. We learn what something is by _doing_ with it.

To draw an example from Papert's _Mindstorms_, learners know what a square is in many ways: they walk in a square, they draw a square, they teach Logo how to draw a square by making a procedure. Drawing on his teacher Jean Piaget's notion of "genetic epistemology" (more on that soon), knowlege is most often an overlay or sedimentation of multiple ways of knowing how to do things. Formal, analytical procedures--a square is a four-sided polygon with 90ยบ internal angles--which pass as knowledge in academic or institutional settings are often very partial, and animated or subtended or founded by tacit, messy, informal ways of knowing things. Logo and its curriculum and its culture are all organized around an acknowledgment of this fact.

To get meta, then: Papert's, and Logo's, theory of knowledge suggests that to know what _Logo_ is, you have to write Logo. One way of parsing this phrase is: you must write code in Logo, and use Logo's various environments, to understand Logo. Indeed! And, in fact, one of our eventual goals is to integrate humanistic knowledge and procedural knowledge in our publication; I am fantasizing about a humanities book that also teaches you how to write code.

There's another way of parsing that, though: to understand Logo, you have to write _a Logo_: a programming language that embodies the pedagogical, epistemological, theoretical, and aesthetic principles of Logo. Our name for that project is: Ludus.

### Hello, Ludus
Ludus is our attempt at something like Logo. "Ludus" is Roger Caillois's term for rule-bound play in _Man, Play, and Games_.

The reasoning behind this name lies in a principle that we've adpoted: Ludus is a dynamic language, but will be as _strict as possible_ while still being dynamic. I should say, I'm using a lot of "we" language here; but this post is all me, pouring out my thoughts after having read scholarship and blog posts and programming language religious wars on discussion boards; followed along with introductory material in Logo, Scheme, Racket, and Pyret; as well as written code in a lot of lanaguages and pushed Javascript just about as far as it might go. The impulses here are, ultimately, however intuitive and aesthetic in nature, with a healthy dash of actual judgment.

When writing code, learners make lots of mistakes. (Hell, experienced coders make lots of mistakes; writing code is hard.) Computer science education and programming language research (of the kind that Shriram Krishnamurthi and others do) has shown that informative (and consistent!) error messages delivered as close in time and space as possible to the commission of the error is very helpful indeed for learners. (Hell, for experienced coders, too; people love the Rust and Elm compilers for good reason.) Languages with strong, static type systems are--in principle or _in potentia_, if not in actual practice--much better at uncovering errors early (at compile time instead of at runtime), and much better at articulating what was wrong (you gave me something that should be an X, but was a Y instead). 

Dynamic lanaguages, meanwhile, get two and a half things wrong here. First: without careful shepherding, programs in dynamic languages tend to surface errors after the fact, only when they run a code path that touches the mistake. You may have made the mistake a while ago, and it's no longer on your mind. This makes diagnosis difficult. For a learner, too, it offers feedback at a rather less opportune time: it lets a mistake slide, and then requires a shift in attention to learn from the error message. First-and-a-half: because of this, the errors often propagate in unexpected ways, so trying to figure out what's wrong at all can be difficult. (Javascript's perfectly awful error, `Undefined is not a function` is truly painful--although part of that stems from JS's myriad design flaws.) And, second: because things like runtime type checking are computationally expensive, to keep a runtime reasonably speedy, the kinds of error messages dynamic languages can offer are often impoverished.

That said, strongly, statically typed languages introduce some very costly cognitive overhead for learners. I remember learning Java at university in the 90s; there were lots of long, magical incantations it took me a long time indeed to understand (`public static void main`). Of course, Java is an extreme example of a language full to the brim of bureaucratic type system boilerplate. Languages like F#, OCaml, and Haskell, with their Hindley-Milner sophisticated type inference, require much, much less boilerplate. Such languages may be ergonomic for experienced programmers (although Haskell is famously obtuse), but learning how to write a function type signature before you write your first function seems like an odd order of operations. To be sure, Elm has made such type systems as friendly as I can imagine, but it comes with its own overhead: it's for webpages, and requires teaching not only Elm but HTML.

Dynamic languages, on the other hand, let learners pay attention to the computation without learning a metalangauge for expressing what's allowed in this computation. (HM typesystems are Turing complete!) Meanwhile, dynamic languages come with an interpreted computing environment. For even if they sacrifice some kinds of fast feedback (good, early error messages) tey also gain others: interactive programming! Logo pioneered this; interactive programming is a huge part of what we're after here.

Of course, Ludus is actually not, in the first instance, a language optimized for learners. It is our attempt at learning about Logo and its culture and contexts by making our own version of Logo. And so, our design space is shaped by the historical investigation it sits alongside (and is ultimately part of). We draw on the tradition of Logo, and Lisps, and Scheme. And so, the way Ludus threads this particular needle is to push that dynamic tradition as far as we possibly can in the direction of strictness and staticness. We want the fast, meaningful feedback that static type systems allow, but without giving up the fast-feedback-interactivity that dynamic languages excel at.

